/*
	Atlas types are used to define how to map Go values into refmt token streams.

	Atlas information may be autogenerated based on struct tags automatically,
	but you can also specify custom AtlasEntry info to use advanced features
	and define custom transformations.

	An Atlas is a collection of AtlasEntry (plus some internal indexing).
	Typical usage is to declare an AtlasEntry for your structs (often near by the
	struct definition), then

	Building an AtlasEntry for some type called `Formula` looks like this:

		atlas.BuildEntry(Formula{}).StructMap().Autogenerate().Complete()

	Building an AtlasEntry always starts with `atlas.BuildEntry(x)` where `x` is
	a dummy object used to convey type information.
	The next function in the chain declares what kind of behavior we're going
	to use to turn that type of object into its serial form.
	(In the above example, we're declaring that we want refmt to see the `Formula`
	type as a struct and traverse its fields.  There are many other options!)
	Subsequent functions are specific to what kind of walking and mapping we've
	chosen.  For struct walking, this may involve declaring fields and custom serial
	names to map them to; for a "Transform" we'd instead have to provide callbacks
	to do the transformation from the `Formula` type to some other type; etcetera.
	The final function in the chain is always called `Complete`, and returns
	a ready-to-use AtlasEntry.

	Building a complete Atlas for a whole suite of serializable types is as
	easy as putting a bunch of them together:

		atlas.Build(
			atlas.BuildEntry(Foo{}).StructMap().Autogenerate().Complete(),
			atlas.BuildEntry(Bar{}).StructMap().Autogenerate().Complete(),
			atlas.BuildEntry(Baz{}).StructMap().Autogenerate().Complete(),
		)

	You can put your entire protocol into one Atlas.
	It's also possible to build several different Atlases each with different
	sets of AtlasEntry.  This may be useful if you have a protocol where some
	messages are not valid during some phases of communication, and you would
	like to use the Atlas as a form of whitelisting for what can be
	marshalled/unmarshalled.
*/
package atlas

import (
	"reflect"
)

type Atlas struct {
	// Map typeinfo to a static description of how that type should be handled.
	// (The internal machinery that will wield this information, and has memory of
	// progress as it does so, is configured using the AtlasEntry, but allocated separately.
	// The machinery is stateful and mutable; the AtlasEntry is not.)
	//
	// We use 'var rtid uintptr = reflect.ValueOf(rt).Pointer()' -- pointer of the
	// value of the reflect.Type info -- as an index.
	// This is both unique and correctly converges when recomputed, and much
	// faster to compare against than reflect.Type (which is an interface that
	// tends to contain fairly large structures).
	mappings map[uintptr]*AtlasEntry

	// Mapping of tag ints to atlasEntry for quick lookups when the
	// unmarshaller hits a tag.  Values are a subset of `mappings`.
	tagMappings map[int]*AtlasEntry
}

// Gets the AtlasEntry for a typeID.  Used by obj package, not meant for user facing.
func (atl Atlas) Get(rtid uintptr) (*AtlasEntry, bool) {
	ent, ok := atl.mappings[rtid]
	return ent, ok
}

// Gets the AtlasEntry for a tag int.  Used by obj package, not meant for user facing.
func (atl Atlas) GetEntryByTag(tag int) (*AtlasEntry, bool) {
	ent, ok := atl.tagMappings[tag]
	return ent, ok
}

/*
	The AtlasEntry is a declarative roadmap of what we should do for
	marshal and unmarshal of a single object, keyed by type.

	There are a lot of paths your mappings might want to take:

	  - For a struct type, you may simply want to specify some alternate keys, or some to leave out, etc.
	  - For an interface type, you probably want to specify one of our interface muxing strategies
	     with a mapping between enumstr:typeinfo (and, what to do if we get a struct we don't recognize).
	  - For a string, int, or other primitive, you don't need to say anything: defaults will DTRT.
	  - For a typedef'd string, int, or other primitive, you *still* don't need to say anything: but,
	     if you want custom behavior (say, transform the string to an int at the last second, and back again),
		 you can specify transformer functions for that.
	  - For a struct type that you want to turn into a whole different kind (like a string): use
	     those same transform functions.  (You'll no longer need a FieldMap.)
	  - For the most esoteric needs, you can fall all the way back to providing a custom MarshalMachine
	     (but avoid that; it's a lot of work, and one of these other transform methods should suffice).
*/
type AtlasEntry struct {
	// The reflect info of the type this morphism is regarding.
	Type reflect.Type

	// --------------------------------------------------------
	// The big escape valves: wanna map to some other kind completely?
	// --------------------------------------------------------

	// Transforms the value we reached by walking (the 'live' value -- which
	// must be of `this.Type`) into another value (the 'serialable' value --
	// which will be of `this.MarshalTransformTargetType`).
	//
	// The target type may be anything, even of a completely different Kind!
	//
	// This transform func runs first, then the resulting value is
	// serialized (by running through the path through Atlas again, so
	// chaining of transform funcs is supported, though not recommended).
	MarshalTransformFunc MarshalTransformFunc
	// The type of value we expect after using the MarshalTransformFunc.
	//
	// The match between transform func and target type should be checked
	// during construction of this AtlasEntry.
	MarshalTransformTargetType reflect.Type

	// Expects a different type (the 'serialable' value -- which will be of
	// 'this.UnmarshalTransformTargetType') than the value we reached by
	// walking (the 'live' value -- which must be of `this.Type`).
	//
	// The target type may be anything, even of a completely different Kind!
	//
	// The unmarshal of that target type will be run first, then the
	// resulting value is fed through this function to produce the real value,
	// which is then placed correctly into bigger mid-unmarshal object tree.
	//
	// For non-primitives, unmarshal of the target type will always target
	// an empty pointer or empty slice, roughly as per if it was
	// operating on a value produced by `TargetType.New()`.
	UnmarshalTransformFunc UnmarshalTransformFunc
	// The type of value we will manufacture an instance of and unmarshal
	// into, then when done provide to the UnmarshalTransformFunc.
	//
	// The match between transform func and target type should be checked
	// during construction of this AtlasEntry.
	UnmarshalTransformTargetType reflect.Type

	// --------------------------------------------------------
	// Standard options for how to map (varies by Kind)
	// --------------------------------------------------------

	// A "tag" to emit when marshalling this type of value;
	// and when unmarshalling, this tag will cause unmarshal to pick
	// this atlas (and if there's conflicting type info, error).
	Tag int
	// Flag for whether the Tag feature should be used (zero is a valid tag).
	Tagged bool

	// A mapping of fields in a struct to serial keys.
	// Only valid if `this.Type.Kind() == Struct`.
	StructMap *StructMap

	// FUTURE: enum-ish primitives, multiplexers for interfaces,
	//  lots of such things will belong here.

	// --------------------------------------------------------
	// Hooks, validate helpers
	// --------------------------------------------------------

	// A validation function which will be called for the whole value
	// after unmarshalling reached the end of the object.
	// If it returns an error, the entire unmarshal will error.
	//
	// Not used in marshalling.
	// Not reachable if an UnmarshalTransform is set.
	ValidateFn func(v interface{}) error
}
