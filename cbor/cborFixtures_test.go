package cbor

import (
	"github.com/polydawn/go-xlate/tok/fixtures"
)

func bcat(bss ...[]byte) []byte {
	l := 0
	for _, bs := range bss {
		l += len(bs)
	}
	rbs := make([]byte, 0, l)
	for _, bs := range bss {
		rbs = append(rbs, bs...)
	}
	return rbs
}

func b(b byte) []byte { return []byte{b} }

var cborFixtures = []struct {
	title    string
	sequence fixtures.Sequence
	serial   []byte
}{
	// Strings and flats.
	{"",
		fixtures.SequenceMap["flat string"],
		bcat(b(0x60+5), []byte(`value`)),
	},
	{"indefinite length string (single actual hunk)",
		fixtures.SequenceMap["flat string"],
		bcat(b(0x7f), b(0x60+5), []byte(`value`), b(0xff)),
	},
	{"indefinite length string (multiple hunks)",
		fixtures.SequenceMap["flat string"],
		bcat(b(0x7f), b(0x60+2), []byte(`va`), b(0x60+3), []byte(`lue`), b(0xff)),
	},
	{"",
		fixtures.SequenceMap["strings needing escape"],
		bcat(b(0x60+17), []byte("str\nbroken\ttabbed")),
	},

	// Maps.
	{"",
		fixtures.SequenceMap["empty map"],
		bcat(b(0xa0)),
	},
	{"indefinite length",
		fixtures.SequenceMap["empty map"].SansLengthInfo(),
		bcat(b(0xbf), b(0xff)),
	},
	{"",
		fixtures.SequenceMap["single row map"],
		bcat(b(0xa0+1),
			b(0x60+3), []byte(`key`), b(0x60+5), []byte(`value`),
		),
	},
	{"indefinite length",
		fixtures.SequenceMap["single row map"].SansLengthInfo(),
		bcat(b(0xbf),
			b(0x60+3), []byte(`key`), b(0x60+5), []byte(`value`),
			b(0xff),
		),
	},
	{"",
		fixtures.SequenceMap["duo row map"],
		bcat(b(0xa0+2),
			b(0x60+3), []byte(`key`), b(0x60+5), []byte(`value`),
			b(0x60+2), []byte(`k2`), b(0x60+2), []byte(`v2`),
		),
	},
	{"indefinite length",
		fixtures.SequenceMap["duo row map"].SansLengthInfo(),
		bcat(b(0xbf),
			b(0x60+3), []byte(`key`), b(0x60+5), []byte(`value`),
			b(0x60+2), []byte(`k2`), b(0x60+2), []byte(`v2`),
			b(0xff),
		),
	},

	// Arrays.
	{"",
		fixtures.SequenceMap["empty array"],
		bcat(b(0x80)),
	},
	{"indefinite length",
		fixtures.SequenceMap["empty array"].SansLengthInfo(),
		bcat(b(0x9f), b(0xff)),
	},
	{"",
		fixtures.SequenceMap["single entry array"],
		bcat(b(0x80+1),
			b(0x60+5), []byte(`value`),
		),
	},
	{"indefinite length",
		fixtures.SequenceMap["single entry array"].SansLengthInfo(),
		bcat(b(0x9f),
			b(0x60+5), []byte(`value`),
			b(0xff),
		),
	},
	{"indefinite length with nested indef string",
		fixtures.SequenceMap["single entry array"].SansLengthInfo(),
		bcat(b(0x9f),
			bcat(b(0x7f), b(0x60+5), []byte(`value`), b(0xff)),
			b(0xff),
		),
	},
	{"",
		fixtures.SequenceMap["duo entry array"],
		bcat(b(0x80+2),
			b(0x60+5), []byte(`value`),
			b(0x60+2), []byte(`v2`),
		),
	},
	{"indefinite length",
		fixtures.SequenceMap["duo entry array"].SansLengthInfo(),
		bcat(b(0x9f),
			b(0x60+5), []byte(`value`),
			b(0x60+2), []byte(`v2`),
			b(0xff),
		),
	},

	// Complex / mixed / nested.
	{"all indefinite length",
		fixtures.SequenceMap["array nested in map as non-first and final entry"].SansLengthInfo(),
		bcat(b(0xbf),
			b(0x60+2), []byte(`k1`), b(0x60+2), []byte(`v1`),
			b(0x60+2), []byte(`ke`), bcat(b(0x9f),
				b(0x60+2), []byte(`oh`),
				b(0x60+4), []byte(`whee`),
				b(0x60+3), []byte(`wow`),
				b(0xff),
			),
			b(0xff),
		),
	},
	{"all indefinite length",
		fixtures.SequenceMap["array nested in map as first and non-final entry"].SansLengthInfo(),
		bcat(b(0xbf),
			b(0x60+2), []byte(`ke`), bcat(b(0x9f),
				b(0x60+2), []byte(`oh`),
				b(0x60+4), []byte(`whee`),
				b(0x60+3), []byte(`wow`),
				b(0xff),
			),
			b(0x60+2), []byte(`k1`), b(0x60+2), []byte(`v1`),
			b(0xff),
		),
	},
	{"",
		fixtures.SequenceMap["maps nested in array"],
		bcat(b(0x80+3),
			bcat(b(0xa0+1),
				b(0x60+1), []byte(`k`), b(0x60+1), []byte(`v`),
			),
			b(0x60+4), []byte(`whee`),
			bcat(b(0xa0+1),
				b(0x60+2), []byte(`k1`), b(0x60+2), []byte(`v1`),
			),
		),
	},
	{"all indefinite length",
		fixtures.SequenceMap["maps nested in array"].SansLengthInfo(),
		bcat(b(0x9f),
			bcat(b(0xbf),
				b(0x60+1), []byte(`k`), b(0x60+1), []byte(`v`),
				b(0xff),
			),
			b(0x60+4), []byte(`whee`),
			bcat(b(0xbf),
				b(0x60+2), []byte(`k1`), b(0x60+2), []byte(`v1`),
				b(0xff),
			),
			b(0xff),
		),
	},
	{"",
		fixtures.SequenceMap["arrays in arrays in arrays"],
		bcat(b(0x80+1), b(0x80+1), b(0x80+0)),
	},
	{"all indefinite length",
		fixtures.SequenceMap["arrays in arrays in arrays"].SansLengthInfo(),
		bcat(b(0x9f), b(0x9f), b(0x9f), b(0xff), b(0xff), b(0xff)),
	},
	{"",
		fixtures.SequenceMap["maps nested in maps"],
		bcat(b(0xa0+1),
			b(0x60+1), []byte(`k`), bcat(b(0xa0+1),
				b(0x60+2), []byte(`k2`), b(0x60+2), []byte(`v2`),
			),
		),
	},
	{"all indefinite length",
		fixtures.SequenceMap["maps nested in maps"].SansLengthInfo(),
		bcat(b(0xbf),
			b(0x60+1), []byte(`k`), bcat(b(0xbf),
				b(0x60+2), []byte(`k2`), b(0x60+2), []byte(`v2`),
				b(0xff),
			),
			b(0xff),
		),
	},
}
